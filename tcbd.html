<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸŒŸ Happy Birthday TC! (12/14) - Shirley ğŸ‚</title>
    
    <link href="https://fonts.googleapis.com/css2?family=Vidaloka&display=swap" rel="stylesheet">

    <style>
        /* è«è˜­è¿ªè‰²ç³»å®šç¾© */
        :root {
            --morandi-blue: #A9B7C7; /* çµ±ä¸€çš„ç°è—è‰² (éœæ…‹æ–‡å­—å’Œ 3D è³€è©) */
            --sapphire-bg: #08122C; /* æ·±è—å¯¶çŸ³èƒŒæ™¯ */
        }
        
        body {
            margin: 0;
            overflow: hidden; 
            font-family: 'Vidaloka', 'Georgia', serif; 
            background-color: var(--sapphire-bg); 
            color: white; 
        }

        #container {
            width: 100vw;
            height: 100vh;
        }

        #overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; 
            z-index: 10;
        }
        
        /* è²éŸ³æç¤ºæŒ‰éˆ• */
        #audio-prompt {
            position: fixed;
            bottom: 20px;
            right: 20px;
            pointer-events: auto; 
            background: rgba(44, 62, 80, 0.8);
            color: white;
            padding: 12px 18px;
            border-radius: 50px; 
            cursor: pointer;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.2);
            transition: opacity 0.5s, transform 0.3s, background-color 0.5s;
            z-index: 20;
            border: none;
            font-size: 1.1em;
            font-weight: bold;
        }
        
        #audio-prompt:hover {
            transform: scale(1.05);
        }
        
        /* éœæ…‹å®šä½æ–‡å­— - è«è˜­è¿ªç°è—è‰²èˆ‡æŸ”å’Œå…‰æšˆ */
        .static-text {
            position: fixed;
            color: var(--morandi-blue); 
            font-weight: 400; 
            letter-spacing: 3px; 
            z-index: 15;
            font-family: 'Vidaloka', 'Georgia', serif; 
            
            /* è«è˜­è¿ªè‰²ç³»æŸ”å’Œå…‰æšˆ */
            text-shadow: 
                0 0 5px rgba(169, 183, 199, 0.8), 
                0 0 15px rgba(169, 183, 199, 0.6), 
                0 0 30px rgba(169, 183, 199, 0.4); 
        }

        #text-top-left {
            top: 20px;
            left: 20px;
            font-size: 3em; 
        }

        #text-bottom-right {
            bottom: 20px;
            right: 20px;
            font-size: 1.8em; 
            text-align: right;
            opacity: 0.9;
        }
        
        .instructions {
            position: fixed;
            top: 20px;
            right: 20px;
            font-size: 1em;
            opacity: 0.7;
            pointer-events: none;
        }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
    <div id="container"></div>

    <div class="static-text" id="text-top-left">To TC</div>
    <div class="static-text" id="text-bottom-right">From Shirley on 2025-12-14</div>
    
    <div id="overlay">
        <div class="instructions">ï¼ˆæ‹–æ›³ç•«é¢å¯æ§åˆ¶æ˜Ÿå¡µçš„è¦–è§’ï¼‰</div>
    </div>
    
    <button id="audio-prompt">ğŸ¶ é»æ­¤æ’­æ”¾éŸ³æ¨‚</button>

    <script>
        let scene, camera, renderer, controls;
        let starField, mobiusRing, textGroup;
        let clock = new THREE.Clock();
        let isMuted = true; 
        
        const audioUrl = 'https://ducj-creator.github.io/wishes/happy-birthday.mp3'; 

        const M_RADIUS = 18;
        const M_WIDTH = 6;
        const M_NUM_PARTICLES = 40000;
        const ART_FONT = 'Vidaloka, Georgia, serif'; 
        
        // çµ±ä¸€çš„è«è˜­è¿ªç°è—è‰²ï¼Œç”¨æ–¼ 3D è³€è©
        const MORANDI_BLUE = '#A9B7C7'; 

        // --- è«æ¯”çƒæ–¯ç’°çš„åƒæ•¸åŒ–æ–¹ç¨‹å‡½æ•¸ (é«”ç©é») ---
        function getMobiusPoint(u, v, radius = M_RADIUS, width = M_WIDTH) {
            let t = u * 2 * Math.PI; 
            let offset = v * width; 
            
            let x = (radius + offset * Math.cos(t / 2)) * Math.cos(t);
            let y = (radius + offset * Math.cos(t / 2)) * Math.sin(t);
            let z = offset * Math.sin(t / 2);
            return new THREE.Vector3(x, y, z);
        }

        // --- è«æ¯”çƒæ–¯ç’°çš„ä¸­å¿ƒè»Œè·¡ (ç”¨æ–¼æ–‡å­—) ---
        function getMobiusPath(t, radius = M_RADIUS, width = M_WIDTH) {
            t = t * 2 * Math.PI; 
            let x = radius * Math.cos(t);
            let y = radius * Math.sin(t);
            let z = width * Math.sin(t / 2) * 2; 
            return new THREE.Vector3(x, y, z);
        }
        
        // --- åˆå§‹åŒ–å ´æ™¯ ---
        function init() {
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            // è¨­ç½®è—å¯¶çŸ³èƒŒæ™¯è‰²
            renderer.setClearColor(0x08122C); 
            document.getElementById('container').appendChild(renderer.domElement);

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 30;
            
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; 
            controls.dampingFactor = 0.05;
            controls.autoRotate = true; 
            controls.autoRotateSpeed = 0.5; 
            controls.maxDistance = 80; 
            controls.minDistance = 15; 

            createStarField();
            createMobiusRingVisual(); 
            createTextSentences(); 

            window.addEventListener('resize', onWindowResize, false);
            animate();
        }
        
        // --- è«æ¯”çƒæ–¯ç’°è¦–è¦ºæ•ˆæœ (é‡‘è‰²åˆ°éŠ€ç™½è‰²æ¼¸è®Šæ˜Ÿå¡µ) ---
        function createMobiusRingVisual() {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(M_NUM_PARTICLES * 3);
            const colors = new Float32Array(M_NUM_PARTICLES * 3);
            const color = new THREE.Color();
            
            const material = new THREE.PointsMaterial({
                size: 0.15, 
                vertexColors: true, 
                blending: THREE.AdditiveBlending, // å‰µé€ ç™¼å…‰æ•ˆæœ
                transparent: true,
                opacity: 1.0, 
                sizeAttenuation: true
            });
            
            for (let i = 0; i < M_NUM_PARTICLES; i++) {
                const u = Math.random() * 1.0; 
                const v = Math.random() * 2 - 1; 
                
                const point = getMobiusPoint(u, v, M_RADIUS, M_WIDTH);
                
                positions[i * 3] = point.x;
                positions[i * 3 + 1] = point.y;
                positions[i * 3 + 2] = point.z;

                // å¯¦ç¾é‡‘è‰²åˆ°éŠ€ç™½è‰²çš„æ¼¸è®Šï¼š
                // æ ¹æ“šè«æ¯”çƒæ–¯ç’°çš„ 'u' åƒæ•¸ (æ²¿ç’°çš„é•·åº¦) æ”¹è®Š HSL è‰²ç›¸ (Hue) å’Œé£½å’Œåº¦ (Saturation)ã€‚
                // HUE (è‰²ç›¸): å¾é‡‘è‰²(0.1)åˆ°ç™½è‰²/éŠ€è‰²(0.0)
                // SATURATION (é£½å’Œåº¦): å¾é«˜é£½å’Œ(1.0)åˆ°ä½é£½å’Œ(0.1)
                
                // å‰µå»ºä¸€å€‹å¾ 0 åˆ° 1 çš„æ¼¸è®Šå› å­
                const gradientFactor = u; 

                // è‰²ç›¸ (H): å¾é‡‘è‰² 0.1 (æ©™é»ƒ) æ¼¸è®Šåˆ° éŠ€ç™½è‰² 0.0 (ç´…è‰²åŸºåº•ï¼Œä½†é£½å’Œåº¦æœƒé™ç‚ºç™½è‰²)
                const h = THREE.MathUtils.lerp(0.1, 0.0, gradientFactor); 
                
                // é£½å’Œåº¦ (S): å¾ 1.0 (é«˜é£½å’Œï¼Œå³æš–é‡‘è‰²) æ¼¸è®Šåˆ° 0.1 (ä½é£½å’Œï¼Œå³éŠ€ç™½è‰²)
                const s = THREE.MathUtils.lerp(1.0, 0.1, gradientFactor); 
                
                // äº®åº¦ (L): ä¿æŒæ¥µé«˜ï¼Œç¢ºä¿ç™¼å…‰æ•ˆæœ
                const l = 1.0 + Math.random() * 0.5; 

                color.setHSL(h, s, l); 
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            mobiusRing = new THREE.Points(geometry, material);
            scene.add(mobiusRing);
        }
        
        // --- 3D ç¥è³€å¥å­ (çµ±ä¸€ä½¿ç”¨è«è˜­è¿ªç°è—è‰²) ---
        function createTextSentences() {
            textGroup = new THREE.Group();
            scene.add(textGroup);

            const sentences = [
                { text: "Happy Birthday", color: MORANDI_BLUE, scale: 2.0 }, 
                { text: "ç”Ÿæ—¥å¿«æ¨‚", color: MORANDI_BLUE, scale: 1.5 }, 
                { text: "èº«é«”å¥åº·", color: MORANDI_BLUE, scale: 1.5 }  
            ];
            
            function createTextSprite(sentence, sentenceColor, sizeScale) {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                
                const FONT_SIZE = 48 * sizeScale;
                context.font = `Bold ${FONT_SIZE}px ${ART_FONT}`; 
                
                const metrics = context.measureText(sentence);
                const textWidth = metrics.width;
                
                canvas.width = textWidth + 40;
                canvas.height = 80 * sizeScale;
                
                context.font = `Bold ${FONT_SIZE}px ${ART_FONT}`;
                context.fillStyle = sentenceColor; 
                
                // è«è˜­è¿ªè‰²ç³»æŸ”å’Œå…‰æšˆ
                context.shadowColor = 'rgba(255, 255, 255, 0.6)'; 
                context.shadowBlur = 10;
                
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(sentence, canvas.width / 2, canvas.height / 2);
                
                const texture = new THREE.CanvasTexture(canvas);
                
                const material = new THREE.SpriteMaterial({ 
                    map: texture, 
                    transparent: true, 
                    blending: THREE.AdditiveBlending,
                    color: new THREE.Color(sentenceColor).multiplyScalar(1.5) 
                });
                const sprite = new THREE.Sprite(material);
                
                sprite.scale.set(1.5 * textWidth / 48, 1.5 * sizeScale, 1.0); 
                return sprite;
            }

            sentences.forEach((s, i) => {
                const sprite = createTextSprite(s.text, s.color, s.scale);
                sprite.userData.phase = i * Math.PI / 3; 
                sprite.userData.pathIndex = i; 
                textGroup.add(sprite);
            });
        }
        
        // --- èƒŒæ™¯æ˜Ÿå¡µ (é‡‘è‰²èª¿) ---
        function createStarField() {
            const starGeometry = new THREE.BufferGeometry();
            const starCount = 15000;
            const positions = [];
            const colors = [];
            const color = new THREE.Color();
            const spread = 300; 

            for (let i = 0; i < starCount; i++) {
                positions.push(
                    (Math.random() - 0.5) * spread,
                    (Math.random() - 0.5) * spread,
                    (Math.random() - 0.5) * spread
                );
                // é‡‘è‰²èª¿çš„èƒŒæ™¯æ˜Ÿå¡µ (è¼ƒæš—)
                color.setHSL(0.1, 0.5, 0.8 + Math.random() * 0.2); 
                colors.push(color.r, color.g, color.b);
            }

            starGeometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(positions), 3));
            starGeometry.setAttribute('color', new THREE.BufferAttribute(new Float32Array(colors), 3));

            const starMaterial = new THREE.PointsMaterial({
                size: 0.2, 
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                transparent: true,
                sizeAttenuation: true 
            });

            starField = new THREE.Points(starGeometry, starMaterial);
            scene.add(starField);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- å‹•ç•«å¾ªç’° ---
        function animate() {
            requestAnimationFrame(animate);

            const elapsedTime = clock.getElapsedTime();
            
            if (starField) {
                starField.rotation.y += 0.0002;
            }
            
            if (mobiusRing) {
                mobiusRing.rotation.z += 0.001; 
            }
            
            // æ›´æ–° 3D å¥å­çµ„çš„ä½ç½®å’Œè·³å‹•æ•ˆæœ
            if (textGroup) {
                const numSentences = textGroup.children.length;
                const pathSpread = 1 / numSentences; 
                
                textGroup.children.forEach((sprite, i) => {
                    const progress = sprite.userData.pathIndex * pathSpread; 
                    const t = elapsedTime * 0.05 + progress; 
                    
                    const centerPos = getMobiusPath(t);
                    
                    const jump = Math.sin(elapsedTime * 0.8 + sprite.userData.phase) * 3.0; 
                    
                    sprite.position.x = centerPos.x;
                    sprite.position.y = centerPos.y;
                    sprite.position.z = centerPos.z + jump;
                });
            }
            
            controls.update(); 
            renderer.render(scene, camera);
        }

        // --- è²éŸ³æ§åˆ¶é‚è¼¯ ---
        let audio;

        function updateAudioButton(muted) {
            const prompt = document.getElementById('audio-prompt');
            if (muted) {
                prompt.textContent = 'ğŸ¶ é»æ­¤æ’­æ”¾éŸ³æ¨‚';
                prompt.style.backgroundColor = 'rgba(44, 62, 80, 0.8)';
            } else {
                prompt.textContent = 'ğŸ”‡ éœéŸ³';
                prompt.style.backgroundColor = 'rgba(231, 76, 60, 0.8)';
            }
        }

        function toggleAudio() {
            if (isMuted) {
                if (audio) {
                    audio.muted = false;
                    audio.play().then(() => {
                        console.log("éŸ³æ¨‚æ’­æ”¾æˆåŠŸï¼");
                    }).catch(e => {
                        console.error("éŸ³æ¨‚æ’­æ”¾å¤±æ•—ï¼Œè«‹æª¢æŸ¥æª”æ¡ˆæ˜¯å¦åœ¨åŒä¸€ä¼ºæœå™¨ä¸”è·¯å¾‘æ­£ç¢ºæˆ–æœ‰ CORS éŒ¯èª¤ã€‚", e);
                        alert("éŸ³è¨Šæ’­æ”¾å¯èƒ½éœ€è¦æ‚¨çš„ç€è¦½å™¨äº’å‹•ã€‚è«‹å†é»æ“Šä¸€æ¬¡æ’­æ”¾æŒ‰éˆ•ã€‚");
                    });
                    isMuted = false;
                    updateAudioButton(false);
                }
            } else {
                if (audio) {
                    audio.muted = true;
                    isMuted = true;
                    updateAudioButton(true);
                }
            }
        }
        
        // é é¢è¼‰å…¥å¾Œï¼Œè‡ªå‹•å•Ÿå‹• 3D æ¸²æŸ“ï¼Œä¸¦æº–å‚™éŸ³æ¨‚
        document.addEventListener('DOMContentLoaded', () => {
            if (!window.WebGLRenderingContext) {
                 alert("æ‚¨çš„ç€è¦½å™¨ä¸æ”¯æŒ WebGLï¼Œ3D è³€å¡ç„¡æ³•é¡¯ç¤ºã€‚");
                 return;
            }
            init();

            audio = new Audio(audioUrl);
            audio.loop = true; 
            audio.volume = 0.5;
            
            document.getElementById('audio-prompt').addEventListener('click', toggleAudio);
            
            // å˜—è©¦éœéŸ³è‡ªå‹•æ’­æ”¾
            audio.muted = true;
            audio.play().then(() => {
                isMuted = true;
                updateAudioButton(true);
                console.log("éŸ³è¨Šå·²é è¼‰å…¥ (éœéŸ³)ã€‚");
            }).catch(e => {
                isMuted = true;
                updateAudioButton(true);
                console.log("éŸ³è¨Šé è¼‰å…¥å¤±æ•—ï¼Œç­‰å¾…ç”¨æˆ¶æ‰‹å‹•é»æ“ŠæŒ‰éˆ•ã€‚");
            });
        });
    </script>
</body>
</html>
